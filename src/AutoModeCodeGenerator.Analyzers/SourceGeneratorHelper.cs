using Microsoft.CodeAnalysis;
using System.Text;

namespace 自动代码生成;

public static class SourceGeneratorHelper
{
#pragma warning disable RS1035 // 不要使用禁用于分析器的 API
    public static Version DotNetVersion => Environment.Version;//输出.NET版本号
#pragma warning restore RS1035 // 不要使用禁用于分析器的 API
    public static string AutoGenerated => $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:{{DotNetVersion}}
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

""";
    public static string AutoCodeAttribute => AutoGenerated + @"
#nullable enable
using System;
namespace AutoCodeGenerator
{
    /// <summary>
    /// 
    /// </summary>
    [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class | AttributeTargets.Property, AllowMultiple = true)]
    public abstract class AutoCodeClassBaseAttribute : Attribute
    {
        /// <summary>
        /// 关联id
        /// </summary>
        public string? Id { get; set; }
        /// <summary>
        /// 名称
        /// </summary>
        public string? Name { get; set; }
        /// <summary>
        /// 前缀
        /// </summary>
        public string? Prefix { get; set; }
        /// <summary>
        /// 后缀
        /// </summary>
        public string? Suffix { get; set; }
        /// <summary>
        /// 修饰符
        /// </summary>
        public AccessibilityEnum Modifier { get; set; }
        /// <summary>
        /// 特性
        /// </summary>
        public string[]? Attributes { get; set; }
        /// <summary>
        /// 注释 描述
        /// </summary>
        public string? Summary { get; set; }
        /// <summary>
        /// 注释 前缀
        /// </summary>
        public string? SummaryPrefix { get; set; }
        /// <summary>
        /// 注释 后缀
        /// </summary>
        public string? SummarySuffix { get; set; }
        /// <summary>
        /// 注释 示例
        /// </summary>
        public string? Example { get; set; }
        /// <summary>
        /// 注释 评论
        /// </summary>
        /// <remarks></remarks>
        public string? Remarks { get; set; }
        /// <summary>
        /// 分部类型
        /// </summary>
        public bool IsPartial { get; set; }
    }

    /// <summary>
    /// Nullable
    /// </summary>
    [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class AutoCodeNullableAttribute : Attribute
    {
        // public AutoCodeNullableAttribute(NullableEnum t)
        // {
        //     this.Type = t;
        // }
        /// <summary>
        ///  Nullable 类型
        /// </summary>
        public NullableEnum Type { get; set; }
    }

    /// <summary>
    /// 接口
    /// </summary>
    [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    public sealed class AutoCodeClassModesAttribute : AutoCodeClassBaseAttribute
    {
        /// <summary>
        /// 继承
        /// </summary>
        public string? InheritStr { get; set; }

        /// <summary>
        /// 继承
        /// </summary>
        public Type? InheritType { get; set; }
        /// <summary>
        /// 接口
        /// </summary>
        public string[]? InterfaceStrs { get; set; }
        /// <summary>
        /// 接口
        /// </summary>
        public Type[]? InterfaceTypes { get; set; }
        /// <summary>
        /// 命名空间
        /// </summary>
        public string? Namespace { get; set; } = string.Empty;
        /// <summary>
        /// 命名空间前缀
        /// </summary>
        public string? NamespacePrefix { get; set; }
        /// <summary>
        /// 命名空间后缀
        /// </summary>
        public string? NamespaceSuffix { get; set; }
        /// <summary>
        /// 派生类
        /// </summary>
        public bool IsAbstract { get; set; }
        /// <summary>
        /// 命名空间引用
        /// </summary>
        public string[]? Usings { get; set; }
        /// <summary>
        /// 继承 Attribute
        /// </summary>
        public bool InheritAttribute { get; set; }
    }

    /// <summary>
    /// 属性
    /// </summary>
    [AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
    public sealed class AutoCodePropertyAttribute : AutoCodeClassBaseAttribute
    {/// <summary>
        /// 关联id
        /// </summary>
        public string[]? Ids { get; set; }
        /// <summary>
        /// 类型
        /// </summary>
        public string? PropertyTypeStr { get; set; }
        /// <summary>
        /// 类型
        /// </summary>
        public Type? PropertyType { get; set; }
        /// <summary>
        /// 允许重写
        /// </summary>
        public bool IsVirtual { get; set; }
        /// <summary>
        /// 允许空
        /// </summary>
        public bool IsNullable { get; set; }
        /// <summary>
        /// 默认值
        /// </summary>
        public string? DefaultValue { get; set; }    }
    /// <summary>
    /// 修饰符
    /// </summary>
    public enum AccessibilityEnum
    {
        /// <summary>
        /// 没有 修饰符
        /// </summary>
        NotApplicable = 0,
        /// <summary>
        /// 访问限于包含类
        /// </summary>
        Private = 1,
        /// <summary>
        /// private protected 访问限于包含类或当前程序集中派生自包含类的类型
        /// </summary>
        ProtectedAndInternal = 2,
        /// <summary>
        /// 访问限于包含类或派生自包含类的类型
        /// </summary>
        Protected = 3,
        /// <summary>
        /// 访问限于当前程序集
        /// </summary>
        Internal = 4,
        /// <summary>
        /// protected internal 访问限于当前程序集或派生自包含类的类型
        /// </summary>
        ProtectedOrInternal = 5,
        /// <summary>
        /// 访问不受限制
        /// </summary>
        Public = 6
    }
    /// <summary>
    /// 
    /// </summary>
    public enum NullableEnum
    {
        /// <summary>
        /// 将可为空注释和警告上下文设置为“已禁用”。
        /// </summary>
        Disable,
        /// <summary>
        /// 将可为空注释和警告上下文设置为“已启用”。
        /// </summary>
        Enable,
        /// <summary>
        /// 将可为空注释和警告上下文还原为项目设置。
        /// </summary>
        Restore,
        /// <summary>
        /// 将可为空注释上下文设置为“已禁用”。
        /// </summary>
        DisableAnnotations,
        /// <summary>
        /// 将可为空注释上下文设置为“已启用”。
        /// </summary>
        EnableAnnotations,
        /// <summary>
        /// 将可为空注释上下文还原为项目设置。
        /// </summary>
        RestoreAnnotations,
        /// <summary>
        /// 将可为空警告上下文设置为“已禁用”。
        /// </summary>
        DisableWarnings,
        /// <summary>
        /// 将可为空警告上下文设置为“已启用”。
        /// </summary>
        EnableWarnings,
        /// <summary>
        /// 将可为空警告上下文还原为项目设置。
        /// </summary>
        RestoreWarnings
    }
}";

    public static string GeneratorCode(NullableEnum? nullable, params SourceGeneratorClassInfo[] generatorClassInfos)
    {
        var sourceBuilder = new StringBuilder(AutoGenerated);
        if (nullable.HasValue)
            sourceBuilder.AppendLine("#nullable " + (nullable.Value switch
            {
                NullableEnum.Enable => "enable",
                NullableEnum.Disable => "disable",
                NullableEnum.Restore => "restore",
                NullableEnum.EnableWarnings => "enable warnings",
                NullableEnum.DisableWarnings => "disable warnings",
                NullableEnum.RestoreWarnings => "restore warnings",
                NullableEnum.EnableAnnotations => "enable annotations",
                NullableEnum.DisableAnnotations => "disable annotations",
                NullableEnum.RestoreAnnotations => "restore annotations",
                _ => throw new NotImplementedException(),
            }));

        //引用
        foreach (var item in generatorClassInfos.SelectMany(f => f.Usings ?? new string[] { }).Distinct().OrderBy(f => f))
            sourceBuilder.AppendLine($"using {item};");
        sourceBuilder.AppendLine();
        foreach (var namespaceInfo in generatorClassInfos.GroupBy(f => f.ClassNamespacePrefix + f.ClassNamespace + f.ClassNamespaceSuffix ?? "").OrderBy(f => f.Key).ToDictionary(f => f.Key))
        {
            if (!string.IsNullOrWhiteSpace(namespaceInfo.Key)) sourceBuilder.AppendLine($"namespace {namespaceInfo.Key}\r\n{{");
            foreach (var classInfo in namespaceInfo.Value)
            {
                sourceBuilder.AppendLine($"\t/// <summary>");
                sourceBuilder.AppendLine($"\t/// " + classInfo.SummaryPrefix + classInfo.Summary + classInfo.SummarySuffix);
                sourceBuilder.AppendLine($"\t/// </summary>");
                if (!string.IsNullOrWhiteSpace(classInfo.Example))
                {
                    sourceBuilder.AppendLine($"\t/// <example>");
                    sourceBuilder.AppendLine($"\t/// " + classInfo.Example);
                    sourceBuilder.AppendLine($"\t/// </example>");
                }
                if (!string.IsNullOrWhiteSpace(classInfo.Remarks))
                {
                    sourceBuilder.AppendLine($"\t/// <remarks>");
                    sourceBuilder.AppendLine($"\t/// " + classInfo.Remarks);
                    sourceBuilder.AppendLine($"\t/// </remarks>");
                }
                var strClassAttributes = string.Join("\r\n", classInfo.Attributes?.Select(f => "\t[" + f + "]") ?? new string[] { });
                if (!string.IsNullOrWhiteSpace(strClassAttributes)) sourceBuilder.AppendLine(strClassAttributes);
                var sss100 = string.Join(", ", new[] { classInfo.Inherit }.Concat(classInfo.Interfaces ?? new string[] { }).Where(f => !string.IsNullOrWhiteSpace(f)));
                var sss101 = new[] { ModifierToString(classInfo.Modifier), classInfo.IsAbstract == true ? "abstract" : "", classInfo.IsPartial == true ? "partial" : "", "class", classInfo.Prefix + classInfo.Name + classInfo.Suffix, string.IsNullOrWhiteSpace(sss100) ? null : ":", sss100 };
                sourceBuilder.AppendLine($"\t{string.Join(" ", sss101.Where(f => !string.IsNullOrWhiteSpace(f)))}\r\n\t{{");
                foreach (var item in classInfo.Propertes ?? new SourceGeneratorPropertyInfo[] { })
                {
                    sourceBuilder.AppendLine($"\t\t/// <summary>");
                    sourceBuilder.AppendLine($"\t\t/// " + item.SummaryPrefix + item.Summary + item.SummarySuffix);
                    sourceBuilder.AppendLine($"\t\t/// </summary>");
                    if (!string.IsNullOrWhiteSpace(item.Example))
                    {
                        sourceBuilder.AppendLine($"\t\t/// <example>");
                        sourceBuilder.AppendLine($"\t\t/// " + item.Example);
                        sourceBuilder.AppendLine($"\t\t/// </example>");
                    }
                    if (!string.IsNullOrWhiteSpace(item.Remarks))
                    {
                        sourceBuilder.AppendLine($"\t\t/// <remarks>");
                        sourceBuilder.AppendLine($"\t\t/// " + item.Remarks);
                        sourceBuilder.AppendLine($"\t\t/// </remarks>");
                    }
                    var strPropertyAttributes = string.Join("\r\n", ((item.Attributes ?? new string[] { }).Concat((classInfo.InheritAttribute ? item.InheritAttributes : null) ?? new string[] { }))?.Select(f => "\t\t[" + f + "]") ?? new string[] { });
                    if (!string.IsNullOrWhiteSpace(strPropertyAttributes)) sourceBuilder.AppendLine(strPropertyAttributes);

                    var sss103 = new[] {
                        ModifierToString(item.Modifier),
                        item.IsVirtual == true ? "virtual" : "",
                        item.Type + (item.IsNullable == true ? "?" : ""),
                        item.Prefix + item.Name + item.Suffix,
                        "{ get; set; }",
                        string.IsNullOrWhiteSpace(item.DefaultValue)?null:$"= {item.DefaultValue};"
                    };
                    sourceBuilder.AppendLine($"\t\t{string.Join(" ", sss103.Where(f => !string.IsNullOrWhiteSpace(f)))}");
                }
                sourceBuilder.AppendLine($"\t}}");
            }
            if (!string.IsNullOrWhiteSpace(namespaceInfo.Key)) sourceBuilder.AppendLine($"}}");
        }
        return sourceBuilder.ToString();
    }

    private static string ModifierToString(Accessibility? accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Private => "private",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => ""
        };
    }
}
